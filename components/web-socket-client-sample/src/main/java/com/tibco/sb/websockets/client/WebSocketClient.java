package com.tibco.sb.websockets.client;

import java.io.IOException;
import java.net.URI;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;

import org.eclipse.jetty.websocket.api.Session;
import org.eclipse.jetty.websocket.api.annotations.OnWebSocketClose;
import org.eclipse.jetty.websocket.api.annotations.OnWebSocketConnect;
import org.eclipse.jetty.websocket.api.annotations.OnWebSocketMessage;
import org.eclipse.jetty.websocket.api.annotations.WebSocket;
import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;
import org.slf4j.Logger;

import com.streambase.sb.CompleteDataType;
import com.streambase.sb.Schema;
import com.streambase.sb.Schema.Field;
import com.streambase.sb.StreamBaseException;
import com.streambase.sb.Tuple;
import com.streambase.sb.operator.Operator;
import com.streambase.sb.operator.Parameterizable;
import com.streambase.sb.operator.TypecheckException;
import com.streambase.sb.util.Util;

/**
 * Generated by JDT StreamBase Client Templates (Version: 7.5.0.1501031450).
 *
 * This class is used as a Java Operator in a StreamBase application.
 * One instance will be created for each Java Operator in a StreamBase 
 * application. 
 * <p>
 * Enqueue methods should only be called from processTuple.
 * <p>
 * If there is any state that the operator instance needs to maintain beyond the
 * lifetime of the instance, the setSessionState/getSessionState methods can
 * be used.
 * @see Parameterizable
 * @see Operator
 * For in-depth information on implementing a custom Java Operator, please see
 * "Developing StreamBase Java Operators" in the StreamBase documentation.
 */
public class WebSocketClient extends Operator implements Parameterizable {

	public static final long serialVersionUID = 1424958255115L;
	private Logger logger;
	// Properties
	private String uri;
	private String contextPath;
	private String displayName = "WebSocket Client";
	// Local variables
	private int inputPorts = 1;
	private int outputPorts = 1;
	private int nextOutputPort = 0;
	private Schema[] outputSchemas; // caches the Schemas given during init() for use at processTuple()
	
	private org.eclipse.jetty.websocket.client.WebSocketClient client;
	private Session webSocketSession;

	/**
	 * The constructor is called when the Operator instance is created, but before the Operator 
	 * is connected to the StreamBase application. We recommended that you set the initial input
	 * port and output port count in the constructor by calling setPortHints(inPortCount, outPortCount).
	 * The default is 1 input port, 1 output port. The constructor may also set default values for 
	 * operator parameters. These values will be displayed in StreamBase Studio when a new instance
	 * of this operator is  dragged to the canvas, and serve as the default values for omitted
	 * optional parameters.
	 */
	public WebSocketClient() {
		super();
		logger = getLogger();
		setPortHints(inputPorts, outputPorts);
		setDisplayName(displayName);
		setShortDisplayName(this.getClass().getSimpleName());
		setUri("ws://localhost:8080");
		setContextPath("/api/1.0");

	}

	/**
	 * The typecheck method is called after the Operator instance is connected in the StreamBase
	 * application, allowing the Operator to validate its properties. The Operator class may 
	 * change the number of input or output ports by calling the requireInputPortCount(portCount)
	 * method or the setOutputSchema(schema, portNum) method. If the verifyInputPortCount method 
	 * is passed a different number of ports than the Operator currently has, a PortMismatchException
	 * (subtype of TypecheckException) is thrown.
	 */
	public void typecheck() throws TypecheckException {
		// typecheck: require a specific number of input ports
		requireInputPortCount(inputPorts);

		// TODO Ensure that all properties have valid values, and typecheck the input schemas here
		
		Schema inputSchema = getInputSchema(0);
        if (!Util.isEmpty("inputMessage") && !inputSchema.hasField("inputMessage")) {
            throw new PropertyTypecheckException("WebSocketClient", "The \"inputMessage\" field must exist in the input tuple.");
        }

		// you must specify a setOutputSchema for each port, so that StreamBase Studio
		// knows how many output ports to draw for the output ports. If you do not
		// use setOutputSchema for each port, the Java Operator on the StreamBase Studio
		// canvas will not display the correct number of output ports.
//		for (int i = 0; i < outputPorts; ++i) {
//			// TODO this example sets every output port Schema the same as the first input port; change this as needed
//			setOutputSchema(i, getInputSchema(0));
//		}
        
        Schema outputSchema = getTypecheckInputSchema(0);
		List<Schema.Field> fields = new ArrayList<Schema.Field>(outputSchema.fields());
		Field messageField = new Schema.Field("message", CompleteDataType.forString());
		if (!fields.contains(messageField))
			fields.add(messageField);
		setOutputSchema(0, new Schema("", fields.toArray(new Schema.Field[] {})));
	}

	/**
	 * This method will be called by the StreamBase server for each Tuple given
	 * to the Operator to process. This is the only time an operator should 
	 * enqueue output Tuples.
	 * @param inputPort the input port that the tuple is from (ports are zero based)
	 * @param tuple the tuple from the given input port
	 * @throws StreamBaseException Terminates the application.
	 */
	public void processTuple(int inputPort, Tuple tuple)
			throws StreamBaseException {
		if (logger.isInfoEnabled()) {
			logger.info("operator processing a tuple at input port" + inputPort);
		}
		// TODO only the first input port is processed; see the template code for typecheck()
		if (inputPort > 0) {
			logger.info("operator skipping tuple at input port" + inputPort);
			return;
		}
		
		if (!tuple.isNull("inputMessage"))
			this.sendMessage(tuple.getString("inputMessage"));

		// create a new output tuple from the Schema at the port we are about to send to
		Tuple out = outputSchemas[inputPort].createTuple();

		// TODO this template just copies each field value from input port 0 (the first input port)
		for (int i = 0; i < out.getSchema().getFieldCount(); ++i) {
			// note: best performance is achieved retrieving values through Tuple#getField(Schema.Field)
			out.setField(i, tuple.getField(i));
		}

		// nextOutputPort is used to send tuples by round-robin on every output port by this template.
		sendOutput(nextOutputPort, out);
		nextOutputPort = (nextOutputPort + 1) % outputPorts;
	}

	/**
	 * If typecheck succeeds, the init method is called before the StreamBase application
	 * is started. Note that your Operator class is not required to define the init method,
	 * unless (for example) you need to perform initialization of a resource such as a JDBC
	 * pool, if your operator is making JDBC calls. StreamBase Studio does not call this
	 * during authoring.
	 */
	public void init() throws StreamBaseException {
		super.init();
		
		try {
        	client = new org.eclipse.jetty.websocket.client.WebSocketClient();
    		WebSocketClientSocket socket = new WebSocketClientSocket();
            
            client.setMaxIdleTimeout(0);
        	
			client.start();
			
			URI destUri = new URI(getUri() + getContextPath());
	        
	        ClientUpgradeRequest request = new ClientUpgradeRequest();
	        System.out.println("Connecting to: " + destUri);
	        client.connect(socket, destUri, request);
		} catch (Exception e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		// for best performance, consider caching input or output Schema.Field objects for
		// use later in processTuple()
		outputSchemas = new Schema[outputPorts];

		for (int i = 0; i < outputPorts; ++i) {
			outputSchemas[i] = getRuntimeOutputSchema(i);
		}
	}

	/**
	 *  The shutdown method is called when the StreamBase server is in the process of shutting down.
	 */
	public void shutdown() {
		try {
			if (client != null && client.isStarted())
				client.stop();
		} catch (Exception e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}

	/***************************************************************************************
	 * The getter and setter methods provided by the Parameterizable object.               *
	 * StreamBase Studio uses them to determine the name and type of each property         *
	 * and obviously, to set and get the property values.                                  *
	 ***************************************************************************************/

	public void setUri(String uri) {
		this.uri = uri;
	}

	public String getUri() {
		return this.uri;
	}

	public void setContextPath(String contextPath) {
		this.contextPath = contextPath;
	}

	public String getContextPath() {
		return this.contextPath;
	}

	/** For detailed information about shouldEnable methods, see interface Parameterizable java doc 
	 *  @see Parameterizable 
	 */

	public boolean shouldEnableUri() {
		// TODO implement custom enablement logic here
		return true;
	}

	public boolean shouldEnableContextPath() {
		// TODO implement custom enablement logic here
		return true;
	}
	
	private void sendMessage (String message) {
		try {
			if (webSocketSession != null)
				webSocketSession.getRemote().sendString(message);
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}

	@WebSocket
    public class WebSocketClientSocket {
        private final CountDownLatch closeLatch = new CountDownLatch(1);

        @OnWebSocketConnect
        public void onConnect(Session session) throws IOException {
        	System.out.println(new Date().toString());
            //System.out.println("Sending message: Hello server");
            //session.getRemote().sendString("Hello server");
        	
        	webSocketSession = session;
        }

        @OnWebSocketMessage
        public void onMessage(String message) {
            System.out.println("Message from Server: " + message);
            
            int portCount = getOutputPortCount();
			for (int i = 0; i < portCount; i++) {
				// TODO Get output schema and create tuple from the schema
				Tuple tuple = getOutputSchema(i).createTuple();

				try {
					tuple.setField("message", message);
					sendOutput(i, tuple);
				} catch (Exception e) {
					System.err.println("Exception sending output to port" + portCount);
					System.err.println(e);
					return;
				}
			}
        }

        @OnWebSocketClose
        public void onClose(int statusCode, String reason) {
            System.out.println("WebSocket Closed. Code: " + statusCode);
            System.out.println(new Date().toString());
        }

        public boolean awaitClose(int duration, TimeUnit unit) throws InterruptedException {
            return this.closeLatch.await(duration, unit);
        }
    }
}
